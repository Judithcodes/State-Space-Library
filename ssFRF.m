%% [f_Vec, magnitude] = ssFRF(SS, makePlot)
%   i) SS = state space model; struct, as generated by createSSmodel.m
%   i) makePlot = [optional argument] boolean; defaults to true if no
%                 argument is provided
%   o) f_Vec = the freq. vector
%   o) magnitude = the magnitude vector

%% Numerical State Space Functions: ssFRF()
% [v1.0] [2019.08.25]
%   -This function is designed to create an approximate frequency response
%    function using the Fourier Transform of the SS system's impulsse
%    response.
%   >I may come back to this and make it closer to how PAK generates its
%    approximate FRFs from impact tests (the FT isn't normalized by the
%    peak time-domain force, but by the FT of the force. This may not be
%    necessary or practical for a mathematically ideal impulse, but we'll
%    have to see.

% SS function used directly:    ssSettlingTime(), ssResponse()
% SS function used indirectly:  createSSmodel()
% Other custom functions used:  modFFT()

function [f_Vec, amplitude] = ssFRF(SS, makePlot)
    if nargin == 1
        makePlot = 1;
    end
    
    dt = 0.001;
    t_End = 1.1*ssSettlingTime(SS, 0.01);
    t_Vec = 0:dt:t_End;
    
    input = zeros(length(t_Vec),SS.n_in);
    input(1,:) = 1/(t_Vec(2)-t_Vec(1)); %Discrete equivalent to an impulse with area 1
    response = ssResponse(SS, input, t_Vec, 0);
    [f_Vec, response_FFT] = modFFT(t_Vec, response, 0);
    amplitude = response_FFT / input(1,1);
    
    if(makePlot)
        figure; hold on; grid on;
        plot(f_Vec, amplitude, 'b');
        title('Approximate Frequency Response Function');
        xlabel('f [Hz]');
        ylabel('Normalized Amplitude [m/N]'); %I could probably find a way to make this more robust
        hold off;
    end
end
