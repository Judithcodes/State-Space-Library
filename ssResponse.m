%% output = ssResponse(SS, input, t_Vec, makePlot)
%   i) SS = state space struct as generated by createSSmodel()
%   i) input = [n_in x t_n] or [t_n x n_in] matrix corresponding to t_Vec
%   i) t_Vec = row or column vector of length t_n
%   i) makePlot = {1, 0.5, 0} results in {plot, plot w/o input, no plot}
%                 {2, 1.5} = results in {animated plot, animated plot w/o
%                 input}
%   o) output = [t_n x n_out] matrix; the SS math is more conducive to
%               the transpose of this form, but I make sure that the output
%               of this function conforms to my standard of column time
%               vectors

%% Numerical State Space Functions: ssResponse()
% [v2.0] [2019.07.31]
%   -Mathematically, it can now handle any number of inputs/outputs
%       > i.e. SISO, SIMO, MISO, or MIMO systems
%   -As far as plotting goes, the SS domain plot only plots the first two
%    states; I don't really know how far I should go to generalize it
%       >I suspect that of MIMO systems I may want to plot, most of them
%        are best going to be visualized by multiple curves on the same 2D
%        plot (I don't forsee needing 3D plots)
%       >I can always expand the functionality of makePlot
% [v3.0] [2019.08.01]
%   -Updated the function to utilize the plot parameters (both time-domain
%    and state space)
%   -The plots are now entirely generalized and can handle MIMO systems;
%    the script that creates the SS model just has to manually change the
%    plot parameters before calling this function
%   >Future improvements: find a way to implement Heun's method or
%    Runga-Cutta, add animated plot feature, add a 3D state plot option
% [v3.1] [2019.08.03]
%   -Added legend labels that specify output and state indeces
% [v3.2] [2019.08.04]
%   -Added the condition that SS.ssPlotDim ~= 0 for the state space plot to
%    be generated

% SS function used directly:    -none-
% SS function used indirectly:  createSSmodel()

function output = ssResponse(SS, input, t_Vec, makePlot)
    dt = t_Vec(2) - t_Vec(1);
    t_n = length(t_Vec);
    
    % Run input buffer on 'input' variable
    sizeIn = size(input);
    if(sizeIn(1) == t_n) %If input is a column vector/matrix
        in = transpose(input);  %in = [n_in, t_n];
    elseif(sizeIn(2) == t_n) %If input is a row vector/matrix
        in = input; %in = [n_in, t_n];
    else
        fprintf('ERROR: input does not match t_Vec\n');
    end
    
    %% CALCULATE SYSTEM RESPONSE (Euler's Method)
    state = zeros(SS.n_states, t_n);      % x
    stateDer = zeros (SS.n_states, t_n);  % x_dot
    out = zeros(SS.n_out, t_n); % y
    
    for i = 1:(t_n-1)
        stateDer(:,i) = SS.A*state(:,i) + SS.B*in(:,i);
        state(:,i+1) = state(:,i) + stateDer(:,i).*dt;
        out(:,i+1) = SS.C*state(:,i) + SS.D*in(:,i);
    end
    output = transpose(out); % trans to [t_n x n_out]
    
    %% GENERATE PLOTS
    if(makePlot > 0)
        figure;
        
        % TIME DOMAIN----------------------------------------
        if(SS.ssPlotDim ~= 0) subplot(1,2,1); end
        hold on;
        grid on;
        if((makePlot ~= 0.5)&&(makePlot ~= 1.5)) %If plotting inputs
            if(SS.tPlot_useDiffY)  yyaxis right;  end
            for p = 1:SS.n_in
                plot(t_Vec, in(p,:), 'DisplayName', sprintf('input_%d', p));
            end
            ylabel(SS.tPlot_InputLabel);
            if(SS.tPlot_useDiffY)  yyaxis left;  end
        end
        for q = 1:SS.n_out
            plot(t_Vec, output(:,q), 'DisplayName', sprintf('output_%d', q));
            ylabel(SS.tPlot_OutputLabel);
        end
        title(sprintf('Time-Domain Response (dt = %.5f)', dt));

        xlabel('Time [s]');
        legend('show');
        hold off;
        
        % STATE SPACE----------------------------------------
        if(SS.ssPlotDim ~= 0)
            subplot(1,2,2);
            hold on;
            grid on;
            numCurves = length(SS.ssPlot_X);
            for k = 1:numCurves
                plot(state(SS.ssPlot_X(k),:), state(SS.ssPlot_Y(k),:), ...
                     'DisplayName',sprintf('states (%d,%d)', SS.ssPlot_X(k), SS.ssPlot_Y(k)) );
            end
            xlabel(SS.ssPlot_XLabel);
            ylabel(SS.ssPlot_YLabel);
            title('State-Space Response');
            legend('show');
            hold off;
        end
        
%         if(makePlot > 1) %If animating plot
%             fps = 20;
%             di = round((1/fps)/dt,0); %Should result in a 20 fps (max) animation
%             if(di<1) di=1; end
%             delta = di*dt; %whatever the length of one frame ends up being
%             n_i = round(t_n/di,0);
%             
%             for i = 1:n_i
%                 subplot(1,2,1);
%                 pause(delta);
%             end
%             
%         end
    end
end