%% [t_sett, SS] = ssSettlingTime(SS, x_sett)
%   i) SS = state space model (struct) generated by createSSmodel() v2.1+
%   i) x_sett = where t_sett will be the (x_sett*100)% settling time
%   o) t_sett = (x_sett*100)% settling time; if its already been calculated
%               and stored in SS, this function will simply retrieve it
%               >NOTE: as of v1.0, this function ONLY looks at the first
%                output of the SS model
%   o) SS = an updated version of SS to which x_sett and t_sett have been
%           added; NOTE: if you call the function like 
%                  "t = ssSettlingTime(SS, 5)"
%           then the function will only return the desired settling time
%           (in other words, you have options here)

%% Numerical State Space Functions: ssSettlingTime()
% [v1.0] [2019.08.03]
%   -This function is designed to approximate the settling time of an
%    arbitrary state space model. To do so, it provides the system with a
%    unit step input and analyzes the response. I've attempted to make it
%    relatively robust and relatively efficient.
%       >My largest concession so far is that it only looks at the first
%        output (so if its a SIMO or MIMO system, welp....)
%   -Developed this function to be used by ssBode()

% SS functions used directly:    -none-
% SS functions used indirectly:  createSSmodel()

function [t_sett, SS] = ssSettlingTime(SS, x_sett)
    DEBUG = false;
    
    % CHECK to see if t_sett has already been found
    n = length(SS.x_settling);
    i_sett = 0;
    for j = 1:n
        if(SS.x_settling(j) == x_sett)
            i_sett = j;
        end
    end
    
    
    if(i_sett ~= 0) %If t_sett has already been found
        t_sett = SS.t_settling(i_sett);
    else
        % CALCULATE Settling Time
        dt = 0.001;
        t_n_block = 5000; %Number of time steps between each expansion of memory
        t_n_check = 2000; %Number of time steps between each settling check (this is the fn's max resolution)
        t_n_tail = 2000;  %Number of time steps used to conduct settling check
        
        settled = false;
        
        in = ones(SS.n_in); %Unit step input
        state = zeros(SS.n_states, t_n_block);      % x
        stateDer = zeros (SS.n_states, t_n_block);  % x_dot
        out = zeros(SS.n_out, t_n_block); % y
        
        ti = 1;                %Current time index
        ti_check = 1;          %Index of last check
        t_n_total = t_n_block; %Current total number of time steps allocated in {state, stateDer, out}
        while(~settled)
            if(ti == t_n_total-2) %if new memory needs to be allocated
                state = [state, zeros(SS.n_states, t_n_block)]; %Add new columns
                stateDer = [stateDer, zeros(SS.n_states, t_n_block)];
                out = [out, zeros(SS.n_out, t_n_block)];
                t_n_total = t_n_total + t_n_block; %Update 
                if(DEBUG) fprintf('Expanded\n'); end
            end
            
            stateDer(:,ti) = SS.A*state(:,ti) + SS.B*in(:);
            state(:,ti+1) = state(:,ti) + stateDer(:,ti).*dt;
            out(:,ti+1) = SS.C*state(:,ti) + SS.D*in(:);
            
            if( (ti-ti_check) == t_n_check)
                check_mean = mean(out(1,ti-t_n_tail:ti));
                check_dev = max(abs(out(1,ti-t_n_tail:ti) - check_mean));
                if(DEBUG) fprintf('(%d) mean = %.5f\t dev = %.5f\n', ti, check_mean, check_dev); end
                if(check_dev <= x_sett*check_mean)
                    settled = true;
                end
                ti_check = ti; %Update index of the last check
            end
            ti = ti + 1; %Increment time step
        end
        t_sett = dt*ti;
        
        % Plot (debugging purposes only)
        if(DEBUG)
            t_Vec = dt*(0:(t_n_total-1));
            figure; grid on; hold on;
            for x = 1:SS.n_out
                plot(t_Vec, out(x,:));
            end
            xlabel('Time [s]');
            ylabel('Output #1');
            title(sprintf('%.2f%% Setting Time = %.5f', (x_sett*100), t_sett));
            hold off;
        end
        
        SS.x_settling = [SS.x_settling; x_sett];
        SS.t_settling = [SS.t_settling; t_sett];
    end

end